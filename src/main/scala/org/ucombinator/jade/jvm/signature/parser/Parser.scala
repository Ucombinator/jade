package org.ucombinator.jade.jvm.signature.parser

import org.ucombinator.jade.jvm.signature.Signature._

import scala.util.parsing.combinator.JavaTokenParsers

// TODO: Modify the traits to guarantee LL(1)
object Parser extends JavaTokenParsers {

  def parseJavaTypeSignature(signature: String): JavaTypeSignature = {
    println(s"input (${signature.length}): $signature")
    parseAll(javaTypeSignature, signature).get
  }

  def parseClassSignature(signature: String): ClassSignature = {
    println(s"input (${signature.length}): $signature")
    parseAll(classSignature, signature).get
  }

  def parseMethodSignature(signature: String): MethodSignature  = {
    println(s"input (${signature.length}): $signature")
    parseAll(methodSignature, signature).get
  }

  // Utility functions

  private def repbra[T](left: => Parser[Any], p: => Parser[T], right: => Parser[Any]): Parser[List[T]] = {
    opt(left ~> rep1(p) <~ right) ^^ (_.getOrElse(Nil))
  }

  implicit private def seqToTuple[A,B,Z](f: (A, B) => Z): A ~ B => Z = {
    case a ~ b => f(a, b)
  }

  implicit private def seqToTuple[A,B,C,Z](f: (A, B, C) => Z): A ~ B ~ C => Z = {
    case a ~ b ~ c => f(a, b, c)
  }

  implicit private def seqToTuple[A,B,C,D,Z](f: (A, B, C, D) => Z): A ~ B ~ C ~ D => Z = {
    case a ~ b ~ c ~ d => f(a, b, c, d)
  }

  // The grammar includes the terminal symbol Identifier to denote the name of a type, field, method, formal parameter, local variable, or type variable, as generated by a Java compiler.
  private lazy val identifier: Parser[Identifier] =
    rep1(acceptIf(isSignatureIdentifierCharacter)("identifier expected but `" + _ + "' found")) ^^
      (x => Identifier(x.mkString))

  // A "Java type signature" represents either a reference type or a primitive type of the Java programming language.
  private lazy val javaTypeSignature: Parser[JavaTypeSignature] =
    baseType | referenceTypeSignature

  private lazy val baseType: Parser[JavaTypeSignature] =
    ("B" | "C" | "D" | "F" | "I" | "J" | "S" | "Z") ^^
      BaseType.valueOf

  // A "reference type signature" represents a reference type of the Java programming language, that is, a class or interface type, a type variable, or an array type.
  private lazy val referenceTypeSignature: Parser[ReferenceTypeSignature] =
    classTypeSignature | typeVariableSignature | arrayTypeSignature

  //// A "class type signature" represents a (possibly parameterized) class or interface type.
  private lazy val classTypeSignature: Parser[ClassTypeSignature] =
    "L" ~> packageSpecifier ~ rep1sep(simpleClassTypeSignature, ".") <~ ";" ^^ ClassTypeSignature

  private lazy val packageSpecifier: Parser[List[Identifier]] =
    rep(identifier <~ "/")

  private lazy val simpleClassTypeSignature: Parser[SimpleClassTypeSignature] =
    identifier ~ typeArguments ^^ SimpleClassTypeSignature

  private lazy val typeArguments: Parser[List[TypeArgument]] =
    repbra("<", typeArgument, ">")

  private lazy val typeArgument: Parser[TypeArgument] = (
    "*" ^^^ UnBoundedTypeArgument
  | opt(wildcardIndicator) ~ referenceTypeSignature ^^ BoundedTypeArgument
  )

  private lazy val wildcardIndicator: Parser[WildcardIndicator] = (
    "+" ^^^ Extends
  | "-" ^^^ Super
  )

  //// A "type variable signature" represents a type variable.
  private lazy val typeVariableSignature: Parser[TypeVariableSignature] =
    "T" ~> identifier <~ ";" ^^ TypeVariableSignature

  //// An "array type signature" represents one dimension of an array type.
  private lazy val arrayTypeSignature: Parser[ArrayTypeSignature] =
    "[" ~> javaTypeSignature ^^ ArrayTypeSignature

  // A "class signature" encodes type information about a (possibly generic) class declaration.
  private lazy val classSignature: Parser[ClassSignature] =
    typeParameters ~ superclassSignature ~ rep(superinterfaceSignature) ^^ ClassSignature

  private lazy val typeParameters: Parser[List[TypeParameter]] =
    repbra("<", typeParameter, ">")

  private lazy val typeParameter: Parser[TypeParameter] =
    identifier ~ classBound ~ rep(interfaceBound) ^^ TypeParameter

  private lazy val classBound: Parser[Option[ReferenceTypeSignature]] =
    ":" ~> opt(referenceTypeSignature)

  private lazy val interfaceBound: Parser[ReferenceTypeSignature] =
    ":" ~> referenceTypeSignature

  private lazy val superclassSignature: Parser[ClassTypeSignature] =
    classTypeSignature

  private lazy val superinterfaceSignature: Parser[ClassTypeSignature] =
    classTypeSignature

  // A method signature encodes type information about a (possibly generic) method declaration.
  private lazy val methodSignature: Parser[MethodSignature] =
    typeParameters ~ ("(" ~> rep(javaTypeSignature) <~ ")") ~ result ~ rep(throwsSignature) ^^ MethodSignature

  private lazy val result: Parser[Result] =
    javaTypeSignature | voidDescriptor

  private lazy val throwsSignature: Parser[ThrowsSignature] =
    "^" ~> (classTypeSignature | typeVariableSignature)

  // The character V indicates that the method returns no value (its result is void).
  private lazy val voidDescriptor: Parser[Result] =
    "V" ^^^ VoidDescriptor
}
