package org.ucombinator.jade.jvm.signature

/** Specified in "The Java Virtual Machine Specification", Section 4.7.9.1
  * <https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1>
  */
object Signature {

  // TODO: if use parser combinator, the `indent` guarantees this!

  // TODO: I should find a way to eliminate this `isJVMIdentifier` function, if I can promise the instances of the case
  // TODO (continue): classes below can only be generated by the parser combinator!!!
  /** All the signature components below which have string identifier field(s)
    * should to verify the identifier(s) with this method */
  private def isJVMIdentifier(id: String): Boolean = {
    require(id != null, "mustn't be `null`")
    // TODO: shouldn't we disallow only: . ; [ / < > :
    // TODO: maybe implement with an implicit conversion from String to an Identifier type
    java.lang.Character.isJavaIdentifierStart(id.head) &&
      id.tail.forall(java.lang.Character.isJavaIdentifierPart)
  }

  // TODO: add a trait with methods: `toCanonicalForm`, `toConponmentList`
  // TODO (CONTINUE): `toJavaSourceCode`

  // A "Java type signature" represents either a reference type or a primitive type of the Java programming language.
  sealed trait JavaTypeSignature extends Result

  sealed trait BaseType extends JavaTypeSignature
  object BaseType {
    val values = List(B, C, D, F, I, J, S, Z)
    val fromString = values.map(v => v.toString -> v).toMap
  }
  case object B extends BaseType // `byte`    - signed byte
  case object C extends BaseType // `char`    - Unicode code point in the Basic Multilingual Plane, encoded with UTF-16
  case object D extends BaseType // `double`  - double-precision floating-point value
  case object F extends BaseType // `float`   - single-precision floating-point value
  case object I extends BaseType // `int`     - integer
  case object J extends BaseType // `long`    - long integer
  case object S extends BaseType // `short`   - signed short
  case object Z extends BaseType // `boolean` - true or false

  // A "reference type signature" represents a reference type of the Java programming language, that is, a class or interface type, a type variable, or an array type.
  sealed trait ReferenceTypeSignature extends JavaTypeSignature

  //// A "class type signature" represents a (possibly parameterized) class or interface type.
  final case class ClassTypeSignature(
    packageSpecifier: PackageSpecifier, classes: List[SimpleClassTypeSignature])
    extends ReferenceTypeSignature with ThrowsSignature {

    require(classes.nonEmpty, "Empty `classes` in `ClassTypeSignature`")
    packageSpecifier foreach { p =>
      require(isJVMIdentifier(p), "An illegal Java identifier in `pkg`!")
    }
  }

  type PackageSpecifier = List[String]

  sealed case class SimpleClassTypeSignature(name: String, typeArguments: TypeArguments) extends {
    require(isJVMIdentifier(name), "An illegal Java identifier - simple class `name`!")
  }

  type TypeArguments = List[TypeArgument]

  sealed abstract class TypeArgument
  final case object UnBoundedTypeArgument extends TypeArgument // *
  final case class BoundedTypeArgument(
    wildcardIndicator: Option[WildcardIndicator],
    signature: ReferenceTypeSignature) extends TypeArgument

  sealed abstract class WildcardIndicator
  case object Extends extends WildcardIndicator // +
  case object Super extends WildcardIndicator   // -

  //// A "type variable signature" represents a type variable.
  final case class TypeVariableSignature(name: String) extends ReferenceTypeSignature with ThrowsSignature {
    require(isJVMIdentifier(name), "An illegal Java identifier - type variable `name`!")
  }

  //// An "array type signature" represents one dimension of an array type.
  final case class ArrayTypeSignature(javaType: JavaTypeSignature) extends ReferenceTypeSignature

  //  object ArrayTypeSignature {
  //    def constructArrayType(typ: JavaTypeSignature, dim: Int): ArrayTypeSignature = {
  //      @tailrec
  //      def helper(t: ArrayTypeSignature, di: Int): ArrayTypeSignature =
  //        di match {
  //          case 0 => t
  //          case d => helper(ArrayTypeSignature(t), d - 1)
  //        }
  //
  //      helper(ArrayTypeSignature(typ), dim - 1)
  //    }
  //  }

  // A "class signature" encodes type information about a (possibly generic) class declaration.
  final case class ClassSignature(typeParameters: TypeParameters,
                                   superClass: SuperclassSignature,
                                   superinterfaces: List[SuperinterfaceSignature])

  type TypeParameters = List[TypeParameter]

  sealed case class TypeParameter(name: String,
                                  superclassBound: ClassBound,
                                  superinterfaceBound: List[InterfaceBound]) {
    require(isJVMIdentifier(name), "An illegal Java identifier - type parameter `name`!")
  }

  type ClassBound = Option[ReferenceTypeSignature]

  type InterfaceBound = ReferenceTypeSignature

  type SuperclassSignature = ClassTypeSignature

  type SuperinterfaceSignature = ClassTypeSignature


  /** MethodSignature */
  sealed case class MethodSignature(typeParameters: Option[TypeParameters],
                                    parameterTypes: List[JavaTypeSignature],
                                    result: Result,
                                    exceptions: List[ThrowsSignature])

  //  /** FieldSignature */
  //  type FieldSignature = ReferenceTypeSignature

  sealed trait Result
  case object VoidDescriptor extends Result  // V

  sealed trait ThrowsSignature
  // ClassTypeSignature implements TThrows
  // TypeVariableSignature implements TThrows

}
