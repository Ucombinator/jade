package org.ucombinator.jade.jvm.signature

import scala.annotation.tailrec

/** JVMS9 - 4.7.9.1 Signatures */
object Signature {

  // TODO: if use parser combinator, the `indent` guarantees this!

  // TODO: I should find a way to eliminate this `isJVMIdentifier` function, if I can promise the instances of the case
  // TODO (continue): classes below can only be generated by the parser combinator!!!
  /** All the signature components below which have string identifier field(s)
    * should to verify the identifier(s) with this method */
  private def isJVMIdentifier(id: String): Boolean = {
    require(id != null, "mustn't be `null`")
    java.lang.Character.isJavaIdentifierStart(id.head) &&
      id.tail.forall(java.lang.Character.isJavaIdentifierPart)
  }

  // TODO: add a trait with methods: `toCanonicalForm`, `toConponmentList`
  // TODO (CONTINUE): `toJavaSourceCode`

  sealed trait TResult
  case object VoidDescriptor extends TResult  // V
  sealed abstract class JavaTypeSignature extends TResult

  sealed trait TThrows
  // ClassTypeSignature implements TThrows
  // TypeVariableSignature implements TThrows

  sealed abstract class BaseType extends JavaTypeSignature
  object BaseType {
    val repr: List[String] = List("B", "C", "D", "F", "I", "J", "S", "Z")

    def BaseTypeOf: Map[String, BaseType] = Map(
      "B" -> B,
      "C" -> C,
      "D" -> D,
      "F" -> F,
      "I" -> I,
      "J" -> J,
      "S" -> S,
      "Z" -> Z
    )
  }

  sealed abstract class ReferenceTypeSignature extends JavaTypeSignature


  /** BaseType subtypes */
  case object B extends BaseType  // `byte`    - signed byte
  case object C extends BaseType  // `char`    - Unicode code point in the Basic Multilingual Plane, encoded with UTF-16
  case object D extends BaseType  // `double`  - double-precision floating-point value
  case object F extends BaseType  // `float`   - single-precision floating-point value
  case object I extends BaseType  // `int`     - integer
  case object J extends BaseType  // `long`    - long integer
  case object S extends BaseType  // `short`   - signed short
  case object Z extends BaseType  // `boolean` - true or false


  /** ReferenceTypeSignature subtypes */
  sealed case class ClassTypeSignature(pkgs: Option[PackageSpecifier],
                                       cls: SimpleClassTypeSignature,
                                       clses: ClassTypeSignatureSuffixes)
    extends ReferenceTypeSignature with TThrows {

    pkgs foreach { p =>
      require(p.forall(isJVMIdentifier), "An illegal Java identifier in `pkg`!")
    }
  }

  type ClassTypeSignatureSuffixes = List[SimpleClassTypeSignature]

  sealed case class TypeVariableSignature(name: String) extends ReferenceTypeSignature with TThrows {
    require(isJVMIdentifier(name), "An illegal Java identifier - type variable `name`!")
  }

  sealed case class ArrayTypeSignature(javaType: JavaTypeSignature) extends ReferenceTypeSignature

  //  object ArrayTypeSignature {
  //    def constructArrayType(typ: JavaTypeSignature, dim: Int): ArrayTypeSignature = {
  //      @tailrec
  //      def helper(t: ArrayTypeSignature, di: Int): ArrayTypeSignature =
  //        di match {
  //          case 0 => t
  //          case d => helper(ArrayTypeSignature(t), d - 1)
  //        }
  //
  //      helper(ArrayTypeSignature(typ), dim - 1)
  //    }
  //  }


  /** ClassTypeSignature subtypes */

  type PackageSpecifier = List[String]

  sealed case class SimpleClassTypeSignature(name: String, typeArguments: TypeArguments) extends {
    require(isJVMIdentifier(name), "An illegal Java identifier - simple class `name`!")
  }

  type TypeArguments = List[TypeArgument]

  sealed abstract class TypeArgument
  sealed case class BoundedTypeArgument(wildcardIndicator: Option[WildcardIndicator],
                                        bound: ReferenceTypeSignature) extends TypeArgument
  case object UnBoundedTypeArgument extends TypeArgument  // *

  sealed abstract class WildcardIndicator
  case object Extends extends WildcardIndicator  // +
  case object Super extends WildcardIndicator    // -

  type ClassTypeSignatureSuffix = SimpleClassTypeSignature

  /** ClassSignature */
  sealed case class ClassSignature(typeParameters: Option[TypeParameters],
                                   superClass: SuperclassSignature,
                                   superinterfaces: List[SuperinterfaceSignature])

  type TypeParameters = List[TypeParameter]

  sealed case class TypeParameter(name: String,
                                  superclassBound: ClassBound,
                                  superinterfaceBound: List[InterfaceBound]) {
    require(isJVMIdentifier(name), "An illegal Java identifier - type parameter `name`!")
  }

  type ClassBound = Option[ReferenceTypeSignature]

  type InterfaceBound = ReferenceTypeSignature

  type SuperclassSignature = ClassTypeSignature

  type SuperinterfaceSignature = ClassTypeSignature


  /** MethodSignature */
  sealed case class MethodSignature(typeParameters: Option[TypeParameters],
                                    parameterTypes: List[JavaTypeSignature],
                                    result: TResult,
                                    exceptions: List[TThrows])

  //  /** FieldSignature */
  //  type FieldSignature = ReferenceTypeSignature

}

