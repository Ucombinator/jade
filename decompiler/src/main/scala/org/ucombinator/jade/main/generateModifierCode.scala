package org.ucombinator.jade.main.generateModifierCode

import org.jsoup.Jsoup
import org.jsoup.nodes.{Document, Element}

import scala.collection.JavaConverters._
import scala.collection.mutable

case class ModifierInfo(acc_name: String, value: Int, keyword: Option[String], kind: String, description: String)

object Main {
  def stringToInt(string: String): Int = { java.lang.Integer.parseInt(string.substring(2), 16) }
  def intToString(int: Int): String = { f"0x$int%04x" }

  def parseTables(document: Document): List[(String, List[ModifierInfo])] = {
    val tables = List[(String, String)](
      "Class" -> "Class access and property modifiers",
      "Field" -> "Field access and property flags",
      "Method" -> "Method access and property flags",
      "NestedClass" -> "Nested class access and property flags")
    for ((kind, tableSummary) <- tables) yield {
      val mutable.Buffer(table) = document.select(f"""table[summary="$tableSummary"]""").asScala
      (kind, for (row <- table.select("tbody > tr").asScala.toList) yield {
        val List(acc_name, value, description) = row.select("td").asScala.toList
        val keyword =
          """(Declared|Marked|Marked or implicitly) <code class="literal">(.*)</code>""".r
            .findFirstMatchIn(description.childNodes().asScala.mkString) match {
          case Some(regexMatch) => Some(regexMatch.group(2))
          case None => None
        }
        ModifierInfo(acc_name.text, stringToInt(value.text), keyword, kind, description.text /*TODO: support <code> */)
      })
    }
  }

  def parseLists(document: Document): List[(String, List[ModifierInfo])] = {
    val lists = List[(String, String)](
      "Parameter" -> "access_flags",
      "Module" -> "module_flags",
      "Requires" -> "requires_flags",
      "Exports" -> "exports_flags",
      "Opens" -> "opens_flags")
    for ((kind, codeLiteral) <- lists) yield {
      val mutable.Buffer(list) = document.select(
        f"dd:has(div[class=variablelist] dl) > p:matchesOwn(The value of the) > code[class=literal]:matchesOwn(^$codeLiteral$$)").asScala
      val rows = list.parent.nextElementSibling.child(0).children().asScala.grouped(2)
      (kind,
        for (mutable.Buffer(row: Element, description: Element) <- rows.toList) yield {
          val regexMatch = """(0x[0-9]*) \(([A-Z_]*)\)""".r.findPrefixMatchOf(row.text).get
          val value = regexMatch.group(1)
          val acc_name = regexMatch.group(2)
          val keyword = if (acc_name == "ACC_TRANSITIVE") { Some("transitive") } else { None }
          ModifierInfo(acc_name, stringToInt(value), keyword, kind, description.text)
        })
    }
  }

  def main(): Unit = {
    val html = scala.io.Source.fromInputStream(System.in).mkString
    val document = Jsoup.parse(html)
    val tables = parseTables(document)
    val lists = parseLists(document)
    val modifierInfos = (tables ++ lists).flatMap(_._2)
    val modifierExtensions = modifierInfos.map(x => x.acc_name -> x.kind).groupBy(_._1).mapValues(_.map(_._2))
    val uniqueModifierInfos = modifierInfos.groupBy(_.acc_name).toList.map(_._2.head).sortBy(_.acc_name).sortBy(_.value)

    println(f"// Do not edit this file by hand.  It is generated by `jade generate-modifier-code`.") // TODO: version
    println("package org.ucombinator.jade.classfile")
    println()

    println(
    """sealed trait Modifier {
      |  def value: Int
      |  def keyword: Option[com.github.javaparser.ast.Modifier.Keyword]
      |  def valueAsString: String = f"0x$value%04x"
      |  def modifier: Option[com.github.javaparser.ast.Modifier] = keyword.map(new com.github.javaparser.ast.Modifier(_))
      |}""".stripMargin)
    println()

    for (kind <- modifierInfos.map(_.kind).distinct) {
      println(f"sealed trait ${kind}Modifier extends Modifier")
    }
    println()

    println(/* TODO: make this private */
      """sealed class ModifierImpl(
        |  override val value: Int,
        |  override val keyword: Option[com.github.javaparser.ast.Modifier.Keyword])
        |  extends Modifier""".stripMargin)
    println()

    println(
      """object Modifier {
        |  def modifiersToNodeList(modifiers: List[Modifier]):
        |    com.github.javaparser.ast.NodeList[com.github.javaparser.ast.Modifier] = {
        |    import scala.collection.JavaConverters._
        |    new com.github.javaparser.ast.NodeList(modifiers.flatMap(_.modifier).asJava)
        |  }
        |
        |  private def fromInt[T](mapping: List[(Int, T)]): Int => List[T] = {
        |    int: Int => {
        |      val maskedInt = int & 0xFFFF // Ignore ASM specific flags, which occur above bit 16
        |      val result = mapping.filter(pair => (pair._1 & maskedInt) != 0)
        |      val intResult = result.map(_._1).fold(0)(_ | _)
        |      assert(maskedInt == intResult, f"modifier parsing error: want 0x$int%x, got 0x$intResult%x")
        |      result.map(_._2)
        |    }
        |  }""".stripMargin)
    println()

    for (modifierInfo <- uniqueModifierInfos) {
      val keyword = modifierInfo.keyword.map("com.github.javaparser.ast.Modifier.Keyword." ++ _.toUpperCase)
      println(
        f"  case object ${modifierInfo.acc_name}\n" +
        f"    extends ModifierImpl(0x${modifierInfo.value}%04x, $keyword)\n" +
        f"    with " + modifierExtensions(modifierInfo.acc_name).map(_ + "Modifier").mkString(" with "))
    }
    println()

    for ((kind, modifierInfosForKind) <- tables ++ lists) {
      assert(modifierInfosForKind.map(_.value) == modifierInfosForKind.map(_.value).distinct)
      println(f"  private val ${kind}Mapping = List[(Int, ${kind}Modifier)](")
      for (modifierInfo <- modifierInfosForKind.sortBy(_.value)) {
        println(f"    (/*0x${modifierInfo.value}%04x*/ ${modifierInfo.acc_name}.value, ${modifierInfo.acc_name}), // ${modifierInfo.description}")
      }
      println("  )")
    }
    println()

    for ((kind, modifierInfosForKind) <- tables ++ lists) {
      println(f"  val intTo$kind: Int => List[${kind}Modifier] = fromInt(${kind}Mapping)")
    }
    println("}")
  }
}
