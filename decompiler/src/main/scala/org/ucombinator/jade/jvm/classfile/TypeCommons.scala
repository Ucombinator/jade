package org.ucombinator.jade.jvm.classfile

import org.ucombinator.jade.jvm.classfile.attribute.signature.JavaTypeSignature
import org.ucombinator.jade.jvm.classfile.descriptor.Descriptor.PrimitiveType

object TypeCommons {
  // The grammar includes the terminal symbol Identifier to denote the name of a
  // type, field, method, formal parameter, local variable, or type variable, as
  // generated by a Java compiler.

  // TODO:
  // Maybe JVMIdentifier when in the future we need to process other JVM languages.

  // TODO: Better name required!!!
  // It is not clear for maintainers about the difference between `Identifier` and the `JavaIdentifier` here.
  sealed case class JavaIdentifier(string: String) {
    require(string.forall(isSignatureIdentifierCharacter),  // TODO: Should also work for "Descriptors"
      f"Illegal JVM signature identifier: $string")
  }

  sealed trait BaseType
    extends PrimitiveType with JavaTypeSignature //  with ArrayElementType

  object BaseType {
    val subTypes: List[BaseType] = List(B, C, D, F, I, J, S, Z)
    val typeOf: Map[String, BaseType] = subTypes.map(v => v.toString -> v).toMap
  }

  case object B extends BaseType // `byte`    - signed byte
  case object C extends BaseType // `char`    - Unicode code point in the Basic Multilingual Plane, encoded with UTF-16
  case object D extends BaseType // `double`  - double-precision floating-point value
  case object F extends BaseType // `float`   - single-precision floating-point value
  case object I extends BaseType // `int`     - integer
  case object J extends BaseType // `long`    - long integer
  case object S extends BaseType // `short`   - signed short
  case object Z extends BaseType // `boolean` - true or false
}
