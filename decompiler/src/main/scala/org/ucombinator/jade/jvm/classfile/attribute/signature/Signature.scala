package org.ucombinator.jade.jvm.classfile.attribute.signature

import scala.language.implicitConversions

import org.ucombinator.jade.jvm.classfile.TypeCommons._

/** JVM signatures as Specified in "The Java Virtual Machine Specification", Section 4.7.9.1
  * <https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1>
  */

// TODO: if use parser combinator, the `indent` guarantees this!

// TODO: I should find a way to eliminate this `isJVMIdentifier` function, if I can promise the instances of the case
// TODO (continue): classes below can only be generated by the parser combinator!!!

// TODO: add a trait with methods: `toCanonicalForm`, `toConponmentList`
// TODO (CONTINUE): `toJavaSourceCode`


// A "Java type signature" represents either a reference type or a primitive type of the Java programming language.
trait JavaTypeSignature
  extends Result

// A "reference type signature" represents a reference type of the Java programming language, that is, a class or interface type, a type variable, or an array type.
sealed trait ReferenceTypeSignature
  extends JavaTypeSignature

//// A "class type signature" represents a (possibly parameterized) class or interface type.
final case class ClassTypeSignature( // L
                                     packageSpecifier: List[JavaIdentifier], classes: List[SimpleClassTypeSignature])
  extends ReferenceTypeSignature with ThrowsSignature {

  require(classes.nonEmpty, "Empty `classes` in `ClassTypeSignature`")
}

final case class SimpleClassTypeSignature(name: JavaIdentifier, typeArguments: List[TypeArgument])

sealed trait TypeArgument
case object UnBoundedTypeArgument extends TypeArgument // *
final case class BoundedTypeArgument(
                                      wildcardIndicator: Option[WildcardIndicator],
                                      signature: ReferenceTypeSignature) extends TypeArgument

sealed trait WildcardIndicator
case object Extends extends WildcardIndicator // +
case object Super extends WildcardIndicator   // -

//// A "type variable signature" represents a type variable.
final case class TypeVariableSignature(name: JavaIdentifier) // T
  extends ReferenceTypeSignature with ThrowsSignature

//// An "array type signature" represents one dimension of an array type.
final case class ArrayTypeSignature(javaType: JavaTypeSignature) // [
  extends ReferenceTypeSignature

// A "class signature" encodes type information about a (possibly generic) class declaration.
final case class ClassSignature(
                                 typeParameters: List[TypeParameter],
                                 superClass: ClassTypeSignature,
                                 superinterfaces: List[ClassTypeSignature])

final case class TypeParameter(
                                name: JavaIdentifier,
                                superclassBound: Option[ReferenceTypeSignature],
                                superinterfaceBound: List[ReferenceTypeSignature])

// A method signature encodes type information about a (possibly generic) method declaration.
final case class MethodSignature(
                                  typeParameters: List[TypeParameter],
                                  parameterTypes: List[JavaTypeSignature],
                                  result: Result,
                                  exceptions: List[ThrowsSignature])

sealed trait Result

sealed trait ThrowsSignature // ^

//// The character V indicates that the method returns no value (its result is void).
case object VoidDescriptor // V
  extends Result

